
# SearchSortGraphTechniques

## You could find some Search and Sort Techniques with Graph Algorithms

Linear Search: A simple search algorithm that iterates through a list of items in a linear manner until the target item is found or the end of the list is reached. It has a time complexity of O(n) where n is the number of items in the list.

Binary Search: A more efficient search algorithm that works on sorted lists by repeatedly dividing the search interval in half until the target item is found or the search interval becomes empty. It has a time complexity of O(log n) where n is the number of items in the list.

Breadth-First Search: A graph traversal algorithm that explores all the vertices of a graph in breadth-first order, i.e., it visits all the neighboring vertices of a vertex before moving on to the next level of vertices. It uses a queue data structure for traversal.

Depth-First Search: A graph traversal algorithm that explores a graph in depth-first order, i.e., it visits a vertex and then recursively visits all its adjacent vertices before backtracking. It uses a stack data structure for traversal.

Insertion Sort: A simple comparison-based sorting algorithm that works by repeatedly inserting an element from an unsorted portion of the list into its correct position in the sorted portion of the list. It has an average time complexity of O(n^2) but can be improved with certain optimizations.

Heap Sort: A comparison-based sorting algorithm that uses a binary heap data structure to efficiently build a sorted array. It has a time complexity of O(n log n) and is typically used for large datasets.

Merge Sort: A comparison-based sorting algorithm that works by dividing the list into two halves, recursively sorting them, and then merging them back into a single sorted list. It has a time complexity of O(n log n) and is known for its stability and consistent performance.

Quick Sort: A comparison-based sorting algorithm that works by selecting a pivot element, partitioning the list around the pivot, and then recursively sorting the two resulting sublists. It has an average time complexity of O(n log n) but can have a worst-case time complexity of O(n^2) in certain cases.

Dijkstra's Algorithm: A graph traversal algorithm that finds the shortest path from a source vertex to all other vertices in a weighted graph. It uses a greedy approach and maintains a set of vertices with known shortest distances.

Prim's Algorithm: A greedy algorithm for finding the minimum spanning tree of a connected, undirected graph. It starts with an arbitrary vertex and grows the tree by iteratively adding the shortest edge that connects a tree vertex to a non-tree vertex.

Floyd-Warshall Algorithm: A dynamic programming algorithm for finding the shortest paths between all pairs of vertices in a weighted graph. It uses a matrix-based approach to compute the shortest paths efficiently.

These are just brief descriptions of each algorithm, and there are many more details and variations to consider when implementing them in practice and You could explore more in the files added here.




